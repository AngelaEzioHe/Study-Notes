# 12.位运算

## 12.2 位运算操作符

| 位运算符 | 含义   | 位运算符 | 含义     |
| -------- | ------ | -------- | -------- |
| &        | 按位与 | ^        | 按位异或 |
| \|       | 按位或 | <<       | 左移     |
| ~        | 取反   | >>       | 右移     |



### 12.2.1 按位与运算符"&"

"&"是双目运算符，使参与运算的两个数的二进制**相与**

规则：**只有**当对应的两个二进制位**均**为1时，结果为1，否则为0。

**eg：**89&38的计算过程如下：

![image-20221120214225157](C:\Users\Thinkpad\AppData\Roaming\Typora\typora-user-images\image-20221120214225157.png)

**发现：**

- 一个用途是**清零**，即想要原数中为1的位置为0，只需将其与对应位置为0的数相与即可；
- 另一个用途是取一个数中的某些特定位，eg：要取22的后5位，使其与后5位均是1的数相与即可。

**【例题】年龄值进行与运算**：

```c
#include<stdio.h>
int main()
{
    unsigned result;
    int age1,age2;
    scanf("%d",&age1);
    scanf("%d",&age2);
    result = age1 & age2 ;
    printf("%d",result);
    return 0;
}
```

输入25和29，输出25。

![image-20221120220414890](C:\Users\Thinkpad\AppData\Roaming\Typora\typora-user-images\image-20221120220414890.png)

------

**注意：**"&"和"&&"的区别：

- "&&"是逻辑与运算符，两个条件同时成立，逻辑与运算结果为真，否则为假；
- "&"是位与运算符，当两个位都为1时，结果为1，否则为0.

------



### 12.2.2 按位或运算符"|"

"|"是双目运算符，使参与运算的两个数的二进制**相或**

规则：**只要**当对应的两个二进制位**有一个**为1时，结果为1，否则为0。

**eg：**17|31的计算过程如下：

![image-20221120221337667](C:\Users\Thinkpad\AppData\Roaming\Typora\typora-user-images\image-20221120221337667.png)

**发现：**

想将某几位变为1，只需将与这几位均为1的数执行相或操作即可。

------



**需要注意**的地方和"&"一样，"|"和"||"有不同的含义，类比"&"



------



### 12.2.3 按位取反运算符"~"

"~"为单目运算符，具有右结合性

**规则：**对参与运算的数的各二进位按位取反，即0变成1，1变成0。



### 12.2.4 按位异或运算符"^"

"^"是双目运算符，使参与运算的两个数对应的二进位相异或。

**规则：**对应的二进位**相异时**结果为1，否则结果为0。

**eg：**107^127的计算过程为：

![image-20221121002621556](C:\Users\Thinkpad\AppData\Roaming\Typora\typora-user-images\image-20221121002621556.png)

**发现：**

- 异或操作的一个主要用途是能使特定的位翻转。eg：想将107的二进制数的后七位翻转，只需与一个后七位都是1的数进行异或操作即可。
- 另一个重要用途是在不使用临时变量的情况下实现两个变量值的互换。

```c
x=x^y;
y=y^x;
x=x^y;
//或者连起来用一行实现：
x^=y^=x^=y;
```

具体运算过程如下：

![image-20221121151557491](C:\Users\Thinkpad\AppData\Roaming\Typora\typora-user-images\image-20221121151557491.png)



### 12.2.5 左移运算符"<<"

**规则：**把"<<"左边的运算数的各个二进位全部左移若干位；"<<"右边的数指定移动的位数，**高位丢弃，低位补0。**

**eg：**假设a=39，a的二进制数为00100111，进行a<<2的操作后，二进制数变成了10011100，对应的十进制数为156。

**发现：**a左移一位相当于给a乘2(**仅限于移出位不包含1的情况**)



### 12.2.6 右移运算符">>"

**规则：**把">>"左边的运算数的各个二进位全部右移若干位；"<<"右边的数指定移动的位数。

**说明：**对于有符号数，右移要注意符号位的问题。

- 正数时：最高位一般补0；
- 负数时：最高位是补0还是补1，取决于编译系统的规定。移入的0称为"逻辑右移"，移入的1称为"算数右移"。



## 12.3 循环移位

如图为循环移位的图示：

![image-20221121191538379](C:\Users\Thinkpad\AppData\Roaming\Typora\typora-user-images\image-20221121191538379.png)

**eg:循环左移：**

分为三步：

1.首先将x的左端n位先放到z的低n位中：

```c
z=x>>(32-n);       //32为一个整型数字所占的字节数
```

2.然后将x左移n位，其右面低n位补0：

```c
y=x<<n;
```

3.最后将y、z进行或运算：

```c
y=y|z;
```



**循环右移也是如此：**

```c
z=x<<(32-n);
y=x>>n;
y=y|z;
```



## 12.4 位段

### 12.4.1 位段的概念与定义

位段是一种特殊的结构体类型，其所有成员的长度**均以二进制位**为单位进行定义，结构体中的成员称为位段。

位段的一般形式如下：

```c
struct 结构体名
{
    类型 变量名 1：长度；
    类型 变量名 2：长度；
    ...
    类型 变量名 n：长度；
}
```

一个位段必须是int、unsigned 或signed 中的一种。

**例如：**CPU的状态寄存器按位段类型定义如下：

```c
struct status
{
    unsigned sign:1;
    unsigned zero:1;
    unsigned carry:1;
    unsigned parity:1;
    unsigned half_carry:1;
    unsigned negative:1;
}flags;
```

