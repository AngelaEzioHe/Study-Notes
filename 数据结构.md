

# 数据结构

## 1. 数据结构绪论

### 1.2 基本概念和术语

#### 1.2.1 数据

是描述客观事物的**符号**，是计算机中可操作的对象。能被计算机识别并输入给计算机。

数据不仅仅包括整型、实型等数值类型，还包括字符、声音、图像、视频等非数值类型。

#### 1.2.2 数据元素

数据元素是组成数据的**基本单位**，在计算机中通常**作为整体处理**。也称之为*记录*。

#### 1.2.3 数据项

一个数据元素可以由若干个数据项组成。

数据项是数据不可分割的最小单位。

#### 1.2.4 数据对象

是**性质相同**的数据元素的集合，是数据的子集。

#### 1.2.5 数据结构

即**关系**

结构指的是组成部分相互搭配和排列的方式。

不同数据元素之间不是独立的，而是存在特定的关系，这些关系称为结构。

**三个方面：**

1. 数据元素之间的逻辑关系，也称为逻辑结构。
2. 数据元素及其关系在计算机内存中的表示（映像），称为数据的物理结构或数据的储存结构。
3. 数据的运算和实现

**两个层次：**

- **逻辑结构**

  - 描述数据元素之间的逻辑关系

  - 与数据的存储无关，独立于计算机

  - 从具体数学问题抽象出来的数学模型

- **物理结构（储存结构）**

  - ​	数据元素及其关系在计算机存储器中的结构（存储方式）
  - 是数据结构在计算机中的表示

- **逻辑结构与存储结构的关系：**

  - 存储结构是逻辑关系的映像与元素本身的映像。
  - 逻辑结构是数据结构的抽象，存储结构是数据结构的实现。
  - 两者综合起来建立了数据元素之间的结构关系。

#### 1.2.6 逻辑结构的种类

**划分方法一：**

1. 线性结构

   **有且仅有**一个开始和一个终端结点，所有结点最多只有一个直接前趋和一个直接后继。

   eg:线性表、栈、队列、串

2. 非线性结构

   一个结点可能有多个直接前趋和直接后继。

   eg:树、图、

**划分方法二：**（四类基本逻辑结构）

1. **集合结构：**结构中的数据元素除了同属于一个集合外，无任何其他关系。
2. **线性结构：**结构中的数据元素之间存在着**一对一**的线性关系。
3. **树形结构：**结构中的数据元素之间存在着**一对多**的层次关系。
4. **图状结构（网状结构）：**结构中的数据元素之间存在着**多对多**的任意关系。

#### 1.2.7 存储结构的种类

1. **顺序存储结构：**
   - 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的储存位置来表示。
   - eg:数组。
2. **链式存储结构：**
   - 用一组任意的存储单元存储数据元素，数据之间的逻辑关系用指针表示。
   - eg:指针
3. **索引存储结构：**
   - 存储结点信息同时，还建立附加的**索引表**
   - 表中每一项称为一个**索引项**
   - **索引项**的一般形式是：（关键字，地址）
   - 关键字是能**唯一标识**一个结点的那些数据项
4. **散列存储结构：**

   - 根据结点的关键字直接计算出该结点的存储地址。

### 1.3 数据类型和抽象数据类型

#### 1.3.1 数据类型

- **定义：**数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称

数据类型=值的类型+值集合上的一组操作



#### 1.3.2 抽象数据类型

**指一个数学模型以及定义在此数学模型上的一组操作。**

- 由用户定义，从问题抽象出**数据模型**（逻辑结构）
- 还包括定义在数据模型上的一组**抽象运算**（相关操作）

**形式定义：**

![image-20221123143240640](C:\Users\Thinkpad\AppData\Roaming\Typora\typora-user-images\image-20221123143240640.png)



### 1.4 算法和算法分析

**定义：**对特定问题的求解方法和步骤的一种描述，是**指令**的有限**序列**。每个指令表示一个或多个操作。

#### 1.4.1 算法的描述

- 自然语言：英语、中文
- 流程图：传统流程图（程序框图）、NS流程图
- 伪代码：类语言：类C语言
- 程序代码：C语言程序、JAVA语言程序

**NS流程图如下：**

<img src="C:\Users\Thinkpad\AppData\Roaming\Typora\typora-user-images\image-20221123215441056.png" alt="image-20221123215441056" style="zoom:50%;" />

#### 1.4.2 算法与程序

- **算法：**解决问题的一个方法或过程，考虑如何将输入转换成输出，一个问题有多种算法。
- **程序：**用某种程序设计语言对算法的具体实现。



#### 1.4.3 算法的特性

- **有穷性：**算法步骤执行有穷步后结束，每一步都在有穷时间内完成。
- **确定性：**算法中的每一条指令必须有确切的含义，没有*二义性*，相同的输入总有相同的输出。
- **可行性：**算法可执行。
- **输入：**一个算法有零个或多个输入。
- **输出：**一个算法有零个或多个输出。



#### 1.4.4算法设计的要求

- **正确性：**一切合法的输入数据都能得到满足要求的结果。
- **可读性：**易于理解，易于debug
- **健壮性：**输入非法数据时 ，算法会做出反应。返回一个表示错误的值，以便继续进行处理，（而不是输出莫名其妙的结果）。
- **高效性：**尽量少的时间和尽量低的存储要求。



#### 1.4.5 时间复杂度

是由嵌套最深层语句的频度决定的

- **最坏时间复杂度：**最坏情况下，算法的时间复杂度。
- **平均时间复杂度：**所有可能输入实例在等概率出现的情况下，算法的期望运行时间。
- **最好时间复杂度：**最好情况下，算法的时间复杂度。

对于复杂的算法，可以分成几个易于估算的部分，利用打O加法法则和乘法法则，计算算法的时间复杂度。



#### 1.4.6 渐进的空间复杂度

即：算法所需存储空间的度量，记作:S(n)=O(f(n)),n为问题的规模。

算法要占据的空间：

1. 本身要占据的空间，输入/输出，指令，常数，变量等；
2. 算法要使用的辅助空间。



## 2.线性表

### 2.1 线性表的定义和特点

线性表是具有相同特性的数据元素的一个有限序列

``eg:(a1,a2,···,a n-2,a n-1,a n)``

- a1: 线性起点
- (a n-2): (a n-1)的直接前趋
- (a n) : (a n-1)的直接后继
- (a n) : 线性节点

**同一线性表中的元素必定具有相同特性，数据元素间的关系是线性关系**

是一种典型的线性结构



### 2.3 线性表的类型定义

#### 2.3.1 基本操作（一）

```c
InitList(&L);
```

结果：构造一个空的线性表L；

```c
DestroyList(&L);
```

初始条件：线性表L已经存在。

结果：销毁线性表L。

```c
ClearList(&L)
```

初始条件：线性表L已经存在。

结果：将线性表L重置为空表。

#### 2.3.2 基本操作（二）

```c
ListEmpty(L)
```

初始条件：线性表L已经存在。

结果：若为空表，返回TRUE;否则返回FALSE。

```c
ListLength(L)
```

初始条件：线性表L已经存在。

结果：返回表中的数据元素个数。

#### 2.3.3 基本操作（三）

```c
GetElem(L,i,&e)
```

初始条件：线性表L已经存在, 1<=i<=ListLength(L)。

结果：用e返回线性表L中第i个数据元素的值。

```c
 LocateElem(L,e,compare())
```

初始条件：线性表L已经存在,compare()是数据元素判定函数。

结果：返回L中第1个与e满足compare()的数据元素的位序。若不存在这样的数据元素则返回值为0.

#### 2.3.4 基本操作（四）

```c
PriorElem(L,cur_e,&pre_e)
```

初始条件：线性表L已经存在。

结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前趋，否则操作失败；pre_e无意义。

```c
NextElem(L,cur_e,&next_e)
```

初始条件：线性表L已经存在。

结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败；next_e无意义。

#### 2.3.5 基本操作（五）

```c
ListInsert(&L,i,e)
```

初始条件：线性表L已经存在, 1 <= i <= ListLength(L)+1 ；

结果：在L的第i个位置之前插入新的数据元素e，L的长度+1。

```c
ListDelete(&l,i,&e)
```

初始条件：线性表L已经存在, 1 <= i <= ListLength(L) ；

结果：删除L的第i个数据元素，并用e返回其值，L的长度-1。

```c
ListTraverse(&L,visited())
```

初始条件：线性表L已经存在。

结果：依次对线性表中每个元素调用visited()。



#### 2.3.6 线性表小结

- 优点：
  - 存储密度大（结点本身所占存储量 / 结点结构所占存储量）
  - 可以随机存取表中任一元素
- 缺点：
  - 在插入。删除某一元素时，需要移动大量元素
  - 浪费存储空间
  - 属于静态存储形式，数据元素个数不能自由扩充

**为了克服这一缺点：**学习链表



### 2.4 线性表的链式表示和实现

- 用一组物理位置任意的存储单元来存放线性表的数据元素
- 存储单元可以连续，可以不连续，甚至可以零散分布在内存中的任意位置上
- 链表中元素的逻辑次序和物理次序不一定相同



#### 2.4.1 与链式存储有关的术语

1. **结点：**数据元素的存储映像。由数据域和指针域两部分组成
2. **链表：**n个结点由指针链组成一个链表。（是线性表的链式存储映像，称为线性表的链式存储结构）
3. **单链表、双链表、循环链表：**
   - 结点只有一个指针域的链表，称为单链表
   - 结点只有两个指针域的链表，称为双链表（一个结点三个域，一个数据域，两个指针域，指向前趋元素和后继元素）
   -  首尾相接的链表称为循环链表



## 3.栈和队列

### 3.1 栈和队列的定义和特点

- 栈和队列是限定插入和删除只能在表的“端点”进行的线性表

**栈**——后进先出（洗盘子，装子弹）

队尾删除，队尾插入（一端）

**队列**——先进先出（排队）

一端插入，另一端删除



#### 3.1.1 栈

- 栈（stack）是特殊的线性表，限定仅在一端（栈顶）进行插入和删除操作的线性表。

表尾（an端）称为栈顶Top；表头（a1）称为栈底Base

插入元素：入栈

删除元素：出栈

**栈与一般线性表的区别：**仅在于运算规则不同（FILO）

#### 3.1.2 队列

- 队列（queue）是一种先进先出（FIFO）的线性表。一端（表尾）插入，另一端（表头）删除



### 3.2 案例引入

#### 3.2.1 进制转换

![进制转换](E:\桌面\Study-Notes\保存截图\进制转换.png)

商除进制取余，进栈，最后依次出栈



#### 3.2.2 括号匹配的检验

- 假设表达式中允许包含两种括号：圆括号和方括号
- 嵌套顺序随意，即：
  1. ***( [ ]  ( ) )为正确格式***
  2. ***[ ( ] ) 为错误格式***

![括号匹配的检验](E:\桌面\Study-Notes\保存截图\括号匹配的检验.png)

判断，遇到左括号，进栈；遇到右括号，和栈顶的括号进行匹配，若可以对应，则将栈顶的左括号取出。



#### 3.2.3 表达式求值

- 表达式组成
  - 操作数（operand）：常数、变量。
  - 运算符（operator）：算术运算符、关系运算符和逻辑运算符。
  - 界限符（delimiter）：左右括弧和表达式结束符。
- 任何一个**算术表达式**都由以上三部分组成。后两者统称为算符。

![表达式求值](E:\桌面\Study-Notes\保存截图\表达式求值.png)



#### 3.2.4 舞伴问题

![舞伴问题](E:\桌面\Study-Notes\保存截图\舞伴问题.png)



### 3.3 栈的表示和实现

#### 3.3.1 栈的抽象数据类型的类型定义

```c
ADT Stack
{
    数据对象：
        D={ai | ai ∈ ElemSet,i=1,2,...,n,n>=0}
    数据关系：
        R1 = {<ai-1,ai> | ai-1,ai∈D,i=2,...,n}
    	约定an端为栈顶，a1端为栈底。
    基本操作：初始化、进栈、出栈、取栈顶元素等
}ADT Stack
```



- InitStack(&S)    初始化操作
  - 结果：构造一个空栈S
- DestroyStack(&S)
  - 结果：栈S被销毁
- StackEmpty(S)    判定S是否为空栈
  - 结果：若S为空栈，返回TRUE，否则返回FALSE
- StackLength(S)    求栈的长度
  - 结果：返回S的元素个数，即栈的长度
- GetTop(S,&e)    取栈顶元素
  - 结果：用e返回S的栈顶元素
- ClearStack(&S)    栈置空操作
  - 将S清为空栈
- Push(&S,e)    入栈操作
  - 结果：插入元素e为新的栈顶元素
- Pop(&S,&e)    出栈操作
  - 结果：删除S栈顶元素an，并用e返回其值



#### 3.3.2 顺序栈的表示和实现

使用数组作为顺序栈存储方式的特点：简单、方便、但易产生溢出（数组大小固定）

- 上溢：栈已经满，又要压入元素
- 下溢：栈已经空，还要弹出元素

**注意：**上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题处理结束。



##### 3.3.2.1 顺序栈的表示



```c
#define MAXSIZE 100
typedef struct
{
    SElemType *base; //栈底指针
    SElemType *top; //栈顶指针
    int stacksize; //栈可用最大容量
}SqStack;
```



**顺序栈的初始化：**

```c
Status InitStack(SqStack &S) //构造一个空栈
{
    S.base = (SElemType*)malloc(MAXIZE*sizeof(SElemType));
    if(!S.base)
    {
        exit(OVERFLOW); //存储分配失败
    }
    S.top = S.base; //栈顶指针等于栈底指针
    S,stacksize = MAXSIZE;
    return OK;
}
```



**顺序栈判断栈是否为空：**

```c
Status StackEmpty(SqStack S) //若栈为空，返回TRUE;否则返回FALSE
{
    if(S.top == S.base)
        return TRUE;
    else
        return FALSE;
}
```



**求顺序栈长度：**

```c
int StackLength(SqStack S)
{
    return S.top - S.base;
}
```



**清空顺序栈：**(让top指向0即可，无所谓栈内存的是什么，因为top在0处，所以认为这是个空栈)

```c
Status ClearStack(SqStack S)
{
    if(S.base)
        S.top = S,base;
    return OK;
}
```



**销毁顺序栈：**

```c
Status DestroyStack(SqStack &S)
{
    if(S.base)
    {
        delete S,base;
        S.stacksize = 0;
        S.base = S.top = NULL;
    }
    return OK;
}
```



**顺序栈的入栈：**

1. 判断是否栈满，若满则出错（上溢）
2. 元素e压入栈顶
3. 栈顶指针+1

```c
Status Push(SqStack &S,SElemType e)
{
    if(S.top - S.base == S.stacksize) //栈满
        return ERROR;
    8S.top = e;
    S.top ++;
    return OK;
}
```



 **顺序栈的出栈：**

1. 判断是否栈空，若满则出错（下溢）
2. 获取栈顶元素e
3. 栈顶指针-1

```c
Status Pop(SqStack &S,) //若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK;否则返回ERROR
{
    if(S.top == S.base)
        retrun ERROR;
    --S.top;
    e = *S.top;
}
```



#### 3.3.3 链栈的表示和实现

```c
typedef struct StackNode
{
    SElemType data;
    struct StackNode *next;
}StackNode,*LinkStack;
LinkStack S;
```



**链栈的初始化：**

```c
void InitStack(LinkStack &S)
{
    if(S == NULL)
        return TRUE;
    else 
        return FALSE;
}
```



**链栈的入栈：**

```c
Status Push(LinkStack &S,SElemType e)
{
    p=nemStackNode; //生成新结点p
    p->data=e; //将新结点数据域置为e
    p->next=S; //将新结点插入栈顶
    S=p; //修改栈顶指针
    return OK;
}
```



**链栈的出栈：**

```c
Status Pop(LinkStack &S,SElemType e)
{
    f(S == NULL)
    {
        e = S-> data;
        p = S;
        S = S->next;
    }
    delete p;
    return OK;
}
```



**取栈顶元素：**

```c
SelemType GetTop(LinkStack S)
{
    if(S != NULL)
        return S->data;
}
```



### 3.4 栈和递归

- **递归的定义**
  - 若一个对象部分地**包含他自己**，或用它**自己给自己定义**，则称这个对象是递归的。
  - 若一个过程**直接或间接地调用自己**，则称这个过程是递归的过程。

**一般形式：**

```c
void p(参数表)
{
    if(递归结束条件)
        可直接求解步骤； ------基本项
    else
        p(较小的参数); ------归纳项
}
```

for example:

```c
long Fact(long n)
{
    if(n == 0)
        return 1;
    else
        return n*Fact(n-1);
}
```

-  递归的优缺点
  - 优点：结构清晰，程序易懂
  - 缺点，每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销比较大。
- 递归->非递归
  1. 尾递归、单向递归->循环结构
  2. 自用栈模拟系统的运行时栈



### 3.5 队列

- **相关术语：** 
  - 队列（Queue）是仅在*表尾*进行插入操作，在*表头*进行删除操作的线性表。
  - 表尾即an端，称尾端；表头即a1端，称队头。
  - 它是一种先进先出（FIFO）的线性表



#### 3.5.2 队列的顺序表示和实现

- **队列的初始化:**

  ```c
  Status InitQueue(SqQueue &Q)
  {
      Q.base =(QelemType*)malloc(MAXQSIZE*sizeof(QElemType)); //分配数组空间
      if(!Q.base)
          exit(OVERFLOW); //存储分配失败
      Q.front = Q.rear = 0; //头指针尾指针置为0.队列为空
      return OK;
  }
  ```

- **求队列的长度：**

  ```c
  int QueueLength(SqQueue Q)
  {
      return ((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);
  }
  ```

- **循环队列入队：**

  ```c
  Status InitQueue(SqQueue &Q , QElemType e)
  {
      if((Q.rear + 1) % MAXQSIZE == Q.front) //队满
          return ERROR;
      Q.base[Q.rear] = e; //新元素加入队尾
      Q.rear = (Q>rear + 1) % MAXQSIZE; //队尾指针+1
      return OK;
  }
  ```

- **循环队列入队：**

  ```c
  Status InitQueue(SqQueue &Q , QElemType e)
  {
      if(Q.front == Q.rear) //队空
          return 0; //保存队头元素
      Q.front = (Q.front + 1) % MAXQSIZE; //队头指针+1
      return OK;
  }
  ```



#### 3.5.3 队列的链式表示和实现

- **定义：**

  ```c
  #define MAXQSIZE 100 //最大队列长度
  typedef struct Qnode
  {
      QElemType data;
      struct Qnode *next;
  }Qnode,*QueuePtr;
  ```

- **链队列初始化：**

  ```c
  Status InitQueue(LinkQueue &Q)
  {
      Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
      if(!Q.front)
          exit(OVERFLOW);
      Q.front -> next = NULL;
      return OK;
  }
  ```

- **链队列的销毁：**

  ```c
  Status DestroyQueue(LinkQueue &Q)
  {
      while(Q.front)
      {
          p = Q.front -> next;
          free(Q.front);
          Q.front = p;
      }
      return OK;
  }
  ```

- **将元素e入队：**

  ```c
  Status EnQueue(LinkQueue &Q ,QElemType e)
  {
      p = (QueuePtr)malloc(sizeof(QNode));
      if(!p)
          exit(OVERFLOW);
      p -> data = e;
      p -> next = NULL;
      Q,rear -> = p;
      return OK;
  }
  ```

- **链队列的出队：**

  ```c
  Status DeQueue(LinkQueue &Q ,QElemType e)
  {
      if(Q.front == Q.rear)
          return ERROR;
      p = Q.front -> next;
      e = p -> data;
      Q.front -> next = p -> next;
      if(Q.rear == p )
          Q.rear = Q.front;
      delete p;
      return OK;
  }
  ```

- **销毁链队列：**

  ```c
  Status DestroyQueue(LinkQueue &Q)
  {
      while(Q.front)
      {
          p = Q.front -> next;
          free(Q.front);
          Q.front = p;
      }
      return OK;
  }
  ```

- **求链队列的队头元素：**

  ```c
  Status GetHead(LinkQueue Q,QElemType &e)
  {
      if(Q.front == Q.rear)
          return ERROR;
      e = Q.front -> next -> data;
      return OK;
  }
  ```

  

